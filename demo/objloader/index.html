<html>
	<head></head>
	<script src="/index.js"></script>
	<script src="../orbitControl.js"></script>

	<body>
		<!-- <svg width="500" height="500">
			<path stroke="red"  d="M100 250 C0 100 500 100 400 250"></path>
			<path stroke="blue"  d="M100 250 L0 200 L500 200 L400 250" fill="transparent"> </path>
		</svg> -->
	</body>
	
	<script>
		const {OBJLoader,MTLLoader} = window.TNTVLayers;
		let model;
		//测试函数
		function main(){
			const loader = new OBJLoader();
			loader.basicMaterial = new THREE.MeshPhongMaterial({color:"#aacefa"});
			
			new MTLLoader().load("./门架.mtl",(materials)=>{
				materials.preload();
				new OBJLoader().setMaterials( materials ).load('./门架.obj',
					function ( object ) {
						object.scale.set(0.05,0.025,0.025);
						object.position.y = 1;
						object.position.x = 10;
						object.children.map(item=>{
							item.castShadow = true;
							object.children.map(item=>{
								item.castShadow = true;
							})
						});
						scene.add( object );
					},
				);
			});
			new MTLLoader().load("./围栏.mtl",(materials)=>{
				materials.preload();
				new OBJLoader().setMaterials( materials ).load('./围栏.obj',
					function ( object ) {
						object.scale.set(0.05,0.025,0.025);
						object.position.y = 0;
						object.position.x = 10;
						object.children.map(item=>{
							item.castShadow = true;
							object.children.map(item=>{
								item.castShadow = true;
							})
						});
						scene.add( object );
					},
				);
			});
			
		}
		
		 

		var scene = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight, 0.1, 10000 );
	
		var renderer = new THREE.WebGLRenderer({antialias :true});
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.BasicShadowMap;
		document.body.appendChild( renderer.domElement );
		var controls = new THREE.OrbitControls( camera, renderer.domElement );
		// controls.autoRotate = true;
		controls.minDistance = 1;
		controls.maxPolarAngle = Math.PI*0.95/2;
		camera.position.set( 30, 30, 50 );
		controls.update();
	
		var axesHelper = new THREE.AxesHelper( 3.75*2+3.5 );
		scene.add( axesHelper );
		var directionalLight = new THREE.DirectionalLight( 0xaacefa, 0.5 );
		directionalLight.position.set(20,50,50);
		directionalLight.castShadow = true;
		directionalLight.shadow.camera.far = 2000;
		var d = 50;
		directionalLight.shadow.mapSize.width = 2048;
		directionalLight.shadow.mapSize.height = 2048;
		directionalLight.shadow.camera.left = - d;
		directionalLight.shadow.camera.right = d;
		directionalLight.shadow.camera.top = d;
		directionalLight.shadow.camera.bottom = - d;

		scene.add( directionalLight );

		var light = new THREE.AmbientLight( 0xffffff,1 ); // soft white light
		scene.add( light );

		// scene.background = new THREE.Color( 0xcce0ff );
		// scene.fog = new THREE.Fog( 0xffffff, 50, 1000 );
		
		const plane = new THREE.Mesh(new THREE.PlaneGeometry(10000,10000),new THREE.MeshLambertMaterial({color:"#555665"}))
		plane.rotation.x = -Math.PI/2;
		plane.position.z = -0.15;
		plane.receiveShadow = true;
		scene.add(plane)

		var animate = function () {
			requestAnimationFrame( animate );
			controls.update();
			// directionalLight.position.copy(camera.position)
			renderer.render( scene, camera );
			
		};
		main();

		animate();

	</script>
</html>